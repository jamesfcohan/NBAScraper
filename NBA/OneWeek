package nba;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.net.*;
import java.util.ArrayList;
import java.util.List;
import java.io.*;

public class NBAScraper {
	
	private int[] _offensiveRebounds;
	private int[] _defensiveRebounds;
	
	public NBAScraper() {
		// initialize arrays for holding the number of offensive and defensive rebounds that resulted from misses for every shot
		// the index of the array will hold all the misses from that many feet
		_offensiveRebounds = new int[150];
		_defensiveRebounds = new int[150];
		
		// get a page of the schedule
		Document schedulePage = this.findSchedule();

		// explores every game on the page of the schedule it is passed
		this.exploreGames(schedulePage);
		
		this.interpretResults();
	}
	
	// gets the schedule webpage
	public Document findSchedule() {
		Document schedulePage = null;
		try {
			schedulePage = Jsoup.connect("http://espn.go.com/nba/schedule/_/date/20131029").timeout(5000).get();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return schedulePage;
	}
	
	/*
	 * this method explores each game on the page of the schedule it is passed
	 * first it gets the links for all of the box scores on the page,
	 * then it goes to each box score page and extracts the link for the play by play page within the box score
	 * then it explores the play by plays
	 */
	public void exploreGames(Document schedulePage) {
		// get a list of all the box score links on the page
		List<String> boxScoreLinks = new ArrayList<String>();
		boxScoreLinks = this.findBoxScoreLinks(schedulePage);
		
		// get a list of all the play by play links within the box score links
		List<String> playByPlayLinks = new ArrayList<String>();
		playByPlayLinks = this.findPlayByPlayLinks(boxScoreLinks);
		
		// go through the play by plays and for every missed shot record the shot distance and whether it led to an offensive or defensive rebound
		this.explorePlayByPlays(playByPlayLinks);
		
	}
	
	
	// this method extracts and returns the links for the box score of each game on the page of the schedule it is passed
	public List<String> findBoxScoreLinks(Document schedulePage){
		// extracts the cells with the scores of games and adds them to scores
		Elements table = schedulePage.getElementsByClass("tablehead");
		Elements rows = table.select("tr:not(tr.colhead)");
		Elements scores = new Elements();
		for (Element row: rows) {
			Elements cells = row.select("td:eq(0):not([colspan]");
			scores.addAll(cells);
		}
		
		// extracts the box score links from the list of cells with the scores of each game
		List<String> boxScoreLinks = new ArrayList<String>();
		Elements links = scores.select("a");
		for (Element link: links) {
			String absUrl = link.absUrl("href");
			boxScoreLinks.add(absUrl);
		}
		return boxScoreLinks;
	}
	
	
	// finds the play by links within the box score links it is passed
	public List<String> findPlayByPlayLinks(List<String> boxScoreLinks) {
		
		List<String> playByPlayLinks = new ArrayList<String>();
		
		for (String url: boxScoreLinks) {
			Document boxScore = null;
			try {
				boxScore = Jsoup.connect(url).timeout(5000).get();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			Elements playByPlayCells = boxScore.select("[href*=playbyplay]");
			for (Element pbpc: playByPlayCells) {
				String playByPlayUrl = pbpc.absUrl("href");
				playByPlayUrl = playByPlayUrl + "&period=0";
				playByPlayLinks.add(playByPlayUrl);
			}
		
		}
		return playByPlayLinks;
	}
	
	public void explorePlayByPlays(List<String> playByPlayLinks) {
		for (String url: playByPlayLinks) {
			Document playByPlayPage = null;
			try {
				playByPlayPage = Jsoup.connect(url).get();
			} catch (IOException e) {
				e.printStackTrace();
			}	
			
			// extracts the cells with the scores of games and adds them to scores
			Elements table = playByPlayPage.getElementsByClass("mod-data");
			Elements rows = table.select("tr");
			for (Element row: rows) {
				// add cells that contain the word misses or blocks
				Elements miss = row.select("td:contains(misses), td:contains(blocks)").not("td:contains(1 of 2)");
				if (!miss.isEmpty()) {
					Element reboundRow = row.nextElementSibling();
					Elements reboundCells = reboundRow.select("td:contains(rebound)");
					if (!reboundCells.isEmpty()) {
						// there has been a miss and a rebound. classify the type of miss
						int missIndex = this.classifyMiss(miss);

						String text = reboundCells.text();
						if (text.contains("offensive")) {
							_offensiveRebounds[missIndex]++;
						}
						else if (text.contains("defensive")) {
							_defensiveRebounds[missIndex]++;
						}
			
					}
				}
			}
			
		}
		
//		// test page
//		String url = "http://espn.go.com/nba/playbyplay?gameId=400488874&period=0";
//		Document playByPlayPage = null;
//		try {
//			playByPlayPage = Jsoup.connect(url).timeout(5000).get();
//		} catch (IOException e) {
//			e.printStackTrace();
//		}	
	}
	// classifies the type of miss it is passed and returns the index of where it should go in the rebound arrays
	public int classifyMiss(Elements miss) {
		String missText = miss.text();
	
		if (missText.contains("layup")){
			return CONSTANTS.LAYUP;
		}
		else if (missText.contains("tip")) {
			return CONSTANTS.TIPSHOT;
		}
		else if (missText.contains("dunk")) {
			return CONSTANTS.DUNK;
		}
		else if (missText.contains("free")) {
			return CONSTANTS.FREETHROW;
		}
		// if it is not one of the above shots, return how many feet away from basket the shot was taken
		else {
			StringBuffer feetBuffer = new StringBuffer();
			for(char c : missText.toCharArray()){
				if(Character.isDigit(c)){
					feetBuffer.append(c);
				}                
	        }
			if (feetBuffer != null && feetBuffer.length() != 0) {
				String feet = feetBuffer.toString();
				return Integer.parseInt(feet);
			}
	    }
		return CONSTANTS.UNCLASSIFIED;
	}
	
	// this method takes in the offensive and defensive rebounding arrays and interprets and prints out their results
	public void interpretResults() {
		for (int i = 0; i < _offensiveRebounds.length; i++) {
			if (_offensiveRebounds[i] !=0 || _defensiveRebounds[i] != 0) {
				if (i == CONSTANTS.UNCLASSIFIED) {
					System.out.print("Offensive rebounds off unclassified shots: " + _offensiveRebounds[i] + "\n");
					System.out.print("Defensive rebounds off unclassified shots: " + _defensiveRebounds[i] + "\n\n");
				}
				else if (i == CONSTANTS.FREETHROW) {
					System.out.print("Offensive rebounds off free throws: " + _offensiveRebounds[i] + "\n");
					System.out.print("Defensive rebounds off free throws: " + _defensiveRebounds[i] + "\n\n");
				}
				else if (i == CONSTANTS.DUNK) {
					System.out.print("Offensive rebounds off dunks: " + _offensiveRebounds[i] + "\n");
					System.out.print("Defensive rebounds off dunks: " + _defensiveRebounds[i] + "\n\n");
				}
				else if (i == CONSTANTS.LAYUP) {
					System.out.print("Offensive rebounds off layups: " + _offensiveRebounds[i] + "\n");
					System.out.print("Defensive rebounds off layups: " + _defensiveRebounds[i] + "\n\n");
				}
				else if (i == CONSTANTS.TIPSHOT) {
					System.out.print("Offensive rebounds off tip shots: " + _offensiveRebounds[i] + "\n");
					System.out.print("Defensive rebounds off tip shots: " + _defensiveRebounds[i] + "\n\n");
				}
				else if (i == 1) {
					System.out.print("Offensive rebounds off shots from 1 foot: " + _offensiveRebounds[1] + "\n");
					System.out.print("Defensive rebounds off shots from 1 foot: " + _defensiveRebounds[1] + "\n\n");
				}
				else {
					System.out.print("Offensive rebounds off shots from "+i+" feet: " + _offensiveRebounds[i] + "\n");
					System.out.print("Defensive rebounds off shots from "+i+" feet: " + _defensiveRebounds[i] + "\n\n");
				}	
			}
		}
	}
}
